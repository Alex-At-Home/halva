### Scala TL/DR for Java Programmers

* Case Classes and Case Objects
  * Case Classes
  * Difference between Case Object and Case Classes
* Pattern Matching and Extraction
* For-Comprehensions

#### Case Class and Case Objects

##### Case Classes

From http://docs.scala-lang.org/tutorials/tour/case-classes.html

> Case classes are regular classes which export their constructor parameters and which provide a recursive decomposition mechanism via pattern matching.

A simpler explanation: a Case Class is a POJO generated from a specification of the fields desired. The generated class will have reasonable toString(), hashCode(), equals(), accessor methods, builders, etc. It also has methods to "deconstruct" instances for use in pattern matching.

##### Case Objects

A Case Object is a specialization of a Case Class. It is a singleton version of a Case Class. Because it is a singleton, it has no fields. It is generated from a similar specification to a Case Class but incldues a singleton definition as well.

### Pattern Matching and Extraction

From http://docs.scala-lang.org/tutorials/tour/pattern-matching

> Scala has a built-in general pattern matching mechanism. It allows to match on any sort of data with a first-match policy.

Pattern matching is like a Java case statement where the cases can contain expressions and variables. As the case clauses are evaluated the variables are filled with matching values that can then be used as part of the case evaluation. The case caluse, if it matches, can also emit a result.

### For-Comprehensions

From http://docs.scala-lang.org/tutorials/tour/sequence-comprehensions

> Comprehensions have the form for (enumerators) yield e, where enumerators refers to a semicolon-separated list of enumerators. An enumerator is either a generator which introduces new variables, or it is a filter. A comprehension evaluates the body e for each binding generated by the enumerators and returns a sequence of these values.

A for-comprehension is like a list of nested Java "for" statements where each nested statement generates a stream that the next statement iterates over. Finally, a "yield" statement emits an item for each iteration and all these items are collected as the result of the comprehension. Technically, a for-comprehension is a series of flatMap() streams ending with a map() stream.
