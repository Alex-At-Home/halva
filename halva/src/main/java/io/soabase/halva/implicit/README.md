### *PREVIEW - ALPHA*

### Implicits

NOTE: If you are not familiar with Scala's Implicits you should review [Scala for Java Programmers](../../../../../../../../SCALA.md) first.

------------

Implicits are generated by the Halva Annotation Processor. You may need to 
[enable Java Annotation processing](../../../../../../../../IDEs.md) in your IDE/build tool).

------------

Halva supports Scala's Implicit injections, though with important differences. Implicit parameters are supported as well as implicit interfaces (for the ["PML" pattern](http://www.artima.com/weblogs/viewpost.jsp?thread=179766)). Recursive implicits (implicits that themselves require implicit parameters) are supported.

In Scala, implicits are injected at the *call site* - the Scala compiler statically analyzes the code and if an implicit is required, the current scope is checked for an available implicit. If one is available, the Scala compiler re-writes the call site to use the implicit value. Halva cannot support this without bytecode writing of some kind. As Halva is committed to using "plain old" Java a different method was chosen.

Halva uses context based implicits and generated implicit classes. A class that is to receive implicits is annotated with `@ImplicitClass`. Parameters can then be annotated with `@Implicit` to receive implicit injections at compile time. Your ImplicitClass can also implement `Implicitly<T>` to have an implicit interface applied. The Halva Annotation Processor generates an implementation that contains the implicit injections. Candidate injections come from classes annotated with `@ImplicitContext`. 

### Reference

Implicits should be thought of as a simple compile-time dependency injection system. In Halva, annotations control the injection process.

#### ImplicitClass

To inject implicit parameters and/or implicitly implement an interface you first define an Implict Class template. This is a class that is annotated with `@ImplicitClass`. The class can extend or implement any other classes/interfaces as needed. The methods of the class (including parameters of the constructor) can be annotation with `@Implicit` to declare that that parameter should be implicitly injected. The Halva Annotation Processor will generated a new class with all of the injections applied. The name of the generated class will be *OriginalName*Impl. However, if you were to name the annotated source class ending with an underscore _, the generated class wouild be named *OriginalName* (i.e. the original name minus the underscore). You can change these defaults with the ImplicitClass attributes suffix() and unsuffix().

Example:

```java
@ImplicitClass
public class MyInjected {
    public MyInjected(@Implicit SomeOtherClass injectMe) {
        ...
    }
}
```

In this case, `MyInjected` is a template class. A new class named `MyInjectedImpl` will be generated with an instance of `SomeOtherClass` injected into the constructor. The constructor for `MyInjectedImpl` will not take any arguments. Candidate instances for implicit injection come from classes annotated with `@ImplicitContext` (see below).

Thus, once generated, you can use the new class like this:

```java
...
MyInjected i = new MyInjectedImpl(); // no need for args - the arg is implicitly injected
```

#### Implicitly

Your Implicit Class templates can specify implicit implementations using `Implicitly`. The Implicit Contexts are searched for implementations of the implict interface and the generated class will then proxy method calls to the injected instance. E.g.

```java
@ImplicitClass
public class MyClass implements Implicitly<Supplier<List<String>>> {
    ...
}
```

This template informs Halva that the generated class should implement `Supplier<List<String>>` and find an implicit injection that provides the definition for `Supplier<List<String>>` and have the generated class forward to it. 

#### ImplicitContext

Classes annotated with `@ImplicitContext` provide the potential implicit injections for `@ImplicitClass` templates. A class annotated with `@ImplicitContext` can contain public static fields or methods that are annotated with `@Implicit`. When an implicit parameter or interface is needed of a specific type, the Implicit Contexts are searched for candidates. E.g.

```java
@ImplicitContext
public void MyImplicits {
    @Implicit public static final SomeOtherClass implicitSomeOtherClass = new SomeOtherClass();
}
```

The above implicit context defines an instance of `SomeOtherClass`. If an Implicit Class requires an implicit instance of `SomeOtherClass`, a reference to `MyImplicits.implicitSomeOtherClass` will be injected.

### Details

#### Limits/Includes/Excludes

Because Halva does not use call-site implicits, another method is provided to limit the scope of which implicits are applied. The `@ImplicitClass` annotation has the `limitContexts` and `excludeContexts` attributes and the `@ImplicitContext` annotation has the `limits` and `excludes` attributes. These combine to control injection candidates. The attributes only apply when they are non empty (the default).

* ImplicitClass.limitContexts - only the listed context classes will be considered when searching for implicit injections
* ImplicitClass.excludeContexts - all *but* the listed context classes will be considered when searching for implicit injections
* ImplicitContext.limits - the context only applies to the listed implicit classes
* ImplicitContext.excludes - the context applies to all *but* the listed implicit classes

#### Field vs Method Implicit Contexts

Implicit Contexts can define implicit injections either by public static field or public static method. A field is straightforward. A method, however, can itself request implicit injection. Like any other implicit injection all applicable contexts are searched for candidates. The new candidate can also be a method with injections and so on. E.g.

```java
@ImplicitContext
public class MainInjections {
    @Implicit public static final Supplier<List<String>> stringSupplier = ...
}

...

@ImplicitContext
public class MoreInjections {
    @Implicit public static MyObject getMyObject(@Implict Supplier<List<String>> supplier) {
        ...
    }
}

...

@ImplicitClass
public class MyClass {
    public MyClass(@Implicit MyObject myObject) {
        ...
    }
}
```

#### Implicit Context for Implicit Interfaces

When `Implicitly` is used to declare an implicit interface, the implementation is provided by searching applicable Implict Contexts. E.g.

```java
@ImplictContext
public class InterfaceProvider {
    @Implicit public static final Supplier<List<String>> stringSupplier = ...
}

...

@ImplicitClass
public class MyClass implements Implicitly<Supplier<List<String>>> {
    ...
}
```

Halva will generate a class named `MyClassImpl` that implements `Supplier<List<String>>`. The overloaded method will proxy to `InterfaceProvider`. The generated class will loosely look like this:

```java
public class MyClassImpl implements Supplier<List<String>> {
    ...
    
    public List<String> get() {
        return InterfaceProvider.stringSupplier.get();
    }
}
```
